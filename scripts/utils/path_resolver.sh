#!/bin/bash
# path_resolver.sh - Handles path resolution and validation

# Exit on error
set -e

# Script directory (absolute path)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/../.." && pwd)"

# Configuration paths
CONFIG_FILE="${REPO_ROOT}/config.env"
KUBE_CONFIG_DEFAULT="/etc/rancher/k3s/k3s.yaml"
KUBE_CONFIG_USER="${HOME}/.kube/config"
KUBE_CONFIG_SYMLINK="/tmp/kubeconfig"

# Create config file if it doesn't exist
if [ ! -f "${CONFIG_FILE}" ]; then
  echo "Creating default configuration file at ${CONFIG_FILE}"
  cat > "${CONFIG_FILE}" << EOF
# Wazuh and OpenTofu Local K3S Configuration
# This file is automatically generated and can be modified

# Kubernetes Configuration
KUBE_CONFIG_PATH="${KUBE_CONFIG_USER}"
KUBE_CONTEXT="default"
WAZUH_NAMESPACE="wazuh"

# Repository Paths
WAZUH_KUBERNETES_REPO="${REPO_ROOT}/wazuh-kubernetes"
WAZUH_KUBERNETES_VERSION="v4.5.0"  # Pin to specific version
TERRAFORM_DIR="${REPO_ROOT}/terraform"
SCRIPTS_DIR="${REPO_ROOT}/scripts"

# Deployment Configuration
STORAGE_CLASS="wazuh-local-storage"
ENVIRONMENT="local"
EOF
fi

# Source the configuration
source "${CONFIG_FILE}"

# Function to validate a path exists
validate_path() {
  local path="$1"
  local description="$2"
  local create_if_missing="$3"

  if [ ! -e "${path}" ]; then
    if [ "${create_if_missing}" = "true" ]; then
      echo "Creating ${description} at ${path}"
      mkdir -p "${path}"
    else
      echo "ERROR: ${description} not found at ${path}"
      return 1
    fi
  else
    echo "✓ ${description} found at ${path}"
  fi
  return 0
}

# Function to resolve the kubeconfig path
resolve_kubeconfig() {
  # Try user's kubeconfig first
  if [ -f "${KUBE_CONFIG_USER}" ]; then
    echo "${KUBE_CONFIG_USER}"
    return 0
  fi

  # Try K3s default location
  if [ -f "${KUBE_CONFIG_DEFAULT}" ]; then
    # Create symlink for compatibility
    ln -sf "${KUBE_CONFIG_DEFAULT}" "${KUBE_CONFIG_SYMLINK}"
    echo "${KUBE_CONFIG_SYMLINK}"
    return 0
  fi

  # Try symlink
  if [ -f "${KUBE_CONFIG_SYMLINK}" ]; then
    echo "${KUBE_CONFIG_SYMLINK}"
    return 0
  fi

  echo ""
  return 1
}

# Function to update config value
update_config() {
  local key="$1"
  local value="$2"

  # Escape special characters in the value
  value=$(echo "${value}" | sed 's/\//\\\//g')

  # Update the config file
  sed -i "s/^${key}=.*/${key}=\"${value}\"/" "${CONFIG_FILE}"
}

# Validate and update kubeconfig path if needed
validate_kubeconfig() {
  local kubeconfig_path=$(resolve_kubeconfig)

  if [ -n "${kubeconfig_path}" ]; then
    # Update config if different
    if [ "${kubeconfig_path}" != "${KUBE_CONFIG_PATH}" ]; then
      update_config "KUBE_CONFIG_PATH" "${kubeconfig_path}"
      KUBE_CONFIG_PATH="${kubeconfig_path}"
    fi
    echo "✓ Kubernetes config found at ${KUBE_CONFIG_PATH}"
    return 0
  else
    echo "ERROR: No valid kubeconfig found"
    return 1
  fi
}

# Main function to validate all paths
validate_all_paths() {
  local exit_code=0

  # Validate repository root
  validate_path "${REPO_ROOT}" "Repository root" "false" || exit_code=1

  # Validate terraform directory
  validate_path "${TERRAFORM_DIR}" "Terraform directory" "false" || exit_code=1

  # Validate scripts directory
  validate_path "${SCRIPTS_DIR}" "Scripts directory" "false" || exit_code=1

  # Validate Wazuh Kubernetes repository
  if ! validate_path "${WAZUH_KUBERNETES_REPO}" "Wazuh Kubernetes repository" "false"; then
    echo "Wazuh Kubernetes repository will be cloned during setup"
  fi

  # Validate kubeconfig
  validate_kubeconfig || exit_code=1

  return ${exit_code}
}

# If script is run directly, validate all paths
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  validate_all_paths
fi